"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[984],{3905:(e,t,r)=>{r.r(t),r.d(t,{MDXContext:()=>p,MDXProvider:()=>u,mdx:()=>h,useMDXComponents:()=>c,withMDXComponents:()=>d});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e},i.apply(this,arguments)}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function o(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var p=n.createContext({}),d=function(e){return function(t){var r=c(t.components);return n.createElement(e,i({},t,{components:r}))}},c=function(e){var t=n.useContext(p),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},u=function(e){var t=c(e.components);return n.createElement(p.Provider,{value:t},e.children)},f="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},x=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(r),u=a,f=d["".concat(s,".").concat(u)]||d[u]||m[u]||i;return r?n.createElement(f,l(l({ref:t},p),{},{components:r})):n.createElement(f,l({ref:t},p))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,s=new Array(i);s[0]=x;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[f]="string"==typeof e?e:a,s[1]=l;for(var p=2;p<i;p++)s[p]=r[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}x.displayName="MDXCreateElement"},18036:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var n=r(87462),a=(r(67294),r(3905));const i={id:"fs"},s="fs type",l={unversionedId:"api/bxl/fs",id:"api/bxl/fs",title:"fs type",description:"Provides some basic tracked filesystem access for bxl functions so that they can meaningfully detect simple properties of artifacts, and source directories.",source:"@site/../docs/api/bxl/fs.generated.md",sourceDirName:"api/bxl",slug:"/api/bxl/fs",permalink:"/docs/api/bxl/fs",draft:!1,tags:[],version:"current",frontMatter:{id:"fs"},sidebar:"manualSidebar",previous:{title:"ensured_artifact_group type",permalink:"/docs/api/bxl/ensured_artifact_group"},next:{title:"instant type",permalink:"/docs/api/bxl/instant"}},o={},p=[{value:"fs.abs_path_unsafe",id:"fsabs_path_unsafe",level:2},{value:"fs.exists",id:"fsexists",level:2},{value:"fs.is_dir",id:"fsis_dir",level:2},{value:"fs.is_file",id:"fsis_file",level:2},{value:"fs.list",id:"fslist",level:2},{value:"fs.project_rel_path",id:"fsproject_rel_path",level:2},{value:"fs.source",id:"fssource",level:2}],d={toc:p};function c(e){let{components:t,...r}=e;return(0,a.mdx)("wrapper",(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,a.mdx)("h1",{id:"fs-type"},(0,a.mdx)("inlineCode",{parentName:"h1"},"fs")," type"),(0,a.mdx)("p",null,"Provides some basic tracked filesystem access for bxl functions so that they can meaningfully detect simple properties of artifacts, and source directories."),(0,a.mdx)("h2",{id:"fsabs_path_unsafe"},"fs.abs","_","path","_","unsafe"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-python"},"def fs.abs_path_unsafe(expr: artifact | file_node | str) -> str\n")),(0,a.mdx)("p",null,"Returns the absolute path, given the file expression. Use at your own risk, as the current working directory may have been changed when this function is called. In addition, passing the absolute path into actions that are run remotely will most likely result in failures since the absolute path most likely differs locally vs remotely."),(0,a.mdx)("p",null,"Sample usage:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-text"},'def _impl_abs_path_unsafe(ctx):\n    ctx.output.print(ctx.fs.abs_path_unsafe("bin"))\n')),(0,a.mdx)("hr",null),(0,a.mdx)("h2",{id:"fsexists"},"fs.exists"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-python"},"def fs.exists(expr: artifact | file_node | str) -> bool\n")),(0,a.mdx)("p",null,"Check if a path exists on disk, taking advantage of Buck's cached filesystem. Takes in a literal, a source artifact (via ",(0,a.mdx)("inlineCode",{parentName:"p"},"artifact"),"), or a ",(0,a.mdx)("inlineCode",{parentName:"p"},"file_node"),"."),(0,a.mdx)("p",null,"Sample usage:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-text"},'def _impl_exists(ctx):\n    ctx.output.print(ctx.fs.exists("bin"))\n')),(0,a.mdx)("hr",null),(0,a.mdx)("h2",{id:"fsis_dir"},"fs.is","_","dir"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-python"},"def fs.is_dir(expr: artifact | file_node | str) -> bool\n")),(0,a.mdx)("p",null,"Returns whether the provided path is a dir. Returns false is the dir does not exist. The input is a either a literal, a source artifact (via ",(0,a.mdx)("inlineCode",{parentName:"p"},"artifact"),"), or a ",(0,a.mdx)("inlineCode",{parentName:"p"},"file_node"),"."),(0,a.mdx)("p",null,"Sample usage:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-text"},'def _impl_is_dir(ctx):\n    ctx.output.print(ctx.fs.is_dir("bin"))\n')),(0,a.mdx)("hr",null),(0,a.mdx)("h2",{id:"fsis_file"},"fs.is","_","file"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-python"},"def fs.is_file(expr: artifact | file_node | str) -> bool\n")),(0,a.mdx)("p",null,"Returns whether the provided path is a file. Returns false is the file does not exist. The input is a either a literal, a source artifact (via ",(0,a.mdx)("inlineCode",{parentName:"p"},"artifact"),"), or a ",(0,a.mdx)("inlineCode",{parentName:"p"},"file_node"),"."),(0,a.mdx)("p",null,"Sample usage:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-text"},'def _impl_is_file(ctx):\n    ctx.output.print(ctx.fs.is_dir("bin"))\n')),(0,a.mdx)("hr",null),(0,a.mdx)("h2",{id:"fslist"},"fs.list"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-python"},"def fs.list(\n    expr: artifact | file_node | str,\n    *,\n    dirs_only: bool = False\n) -> read_dir_set\n")),(0,a.mdx)("p",null,"Returns all the contents of the given input that points to a directory. Errors if the given path is a file. Takes an optional boolean ",(0,a.mdx)("inlineCode",{parentName:"p"},"dirs_only")," to only return directories, defaults to false."),(0,a.mdx)("p",null,"The input is a either a literal, a source artifact (via ",(0,a.mdx)("inlineCode",{parentName:"p"},"artifact"),"), or a ",(0,a.mdx)("inlineCode",{parentName:"p"},"file_node"),"."),(0,a.mdx)("p",null,"Sample usage:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-text"},'def _impl_list(ctx):\n    list_results = ctx.fs.list("bin")\n    for result in list_results:\n        ctx.output.print(result)\n')),(0,a.mdx)("hr",null),(0,a.mdx)("h2",{id:"fsproject_rel_path"},"fs.project","_","rel","_","path"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-python"},"def fs.project_rel_path(expr: artifact | file_node | str) -> str\n")),(0,a.mdx)("p",null,"Returns the relative path to the project root, given the file expression."),(0,a.mdx)("p",null,"Sample usage:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-text"},'def project_rel_path(ctx):\n    ctx.output.print(ctx.fs.project_rel_path("bin"))\n')),(0,a.mdx)("hr",null),(0,a.mdx)("h2",{id:"fssource"},"fs.source"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-python"},"def fs.source(\n    expr: artifact | file_node | str,\n    target_hint: None | str | target_label | target_set | unconfigured_target_node | list[str | target_label | unconfigured_target_node] = None\n) -> artifact\n")),(0,a.mdx)("p",null,"Returns the source artifact for a path and an optional target hint (unconfigured target label or node) which points to the owning package. If no target hint is given, the nearest package will be used to guess the desired artifact. The path should be either an absolute path, or a project relative path."))}c.isMDXComponent=!0}}]);